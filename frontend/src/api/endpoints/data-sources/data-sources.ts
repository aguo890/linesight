/**
 * Generated by orval v7.13.2 üç∫
 * Do not edit manually.
 * LineSight
 * LineSight: AI-driven Semantic ETL platform for SMB apparel manufacturing. Parse messy Excel files, track SAM/DHU metrics, and ensure UFLPA compliance.
 * OpenAPI spec version: 0.1.0
 */
import {
  useMutation,
  useQuery
} from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import type {
  DataSourceCreate,
  DataSourceResponse,
  DataSourceUpdate,
  GetDataSourceByLineApiV1DatasourcesLineLineIdGet200,
  GetDatasourceByLineExplicitApiV1DatasourcesByLineProductionLineIdGet200,
  HTTPValidationError,
  ListDataSourcesApiV1DatasourcesGetParams,
  SchemaMappingCreate,
  SchemaMappingResponse
} from '../../model';

import { customInstance } from '../../axios-client';


type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];



/**
 * Create a new data source for a production line.
 * @summary Create Data Source
 */
export const createDataSourceApiV1DatasourcesPost = (
    dataSourceCreate: DataSourceCreate,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<DataSourceResponse>(
      {url: `/api/v1/datasources`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: dataSourceCreate, signal
    },
      options);
    }
  


export const getCreateDataSourceApiV1DatasourcesPostMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createDataSourceApiV1DatasourcesPost>>, TError,{data: DataSourceCreate}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof createDataSourceApiV1DatasourcesPost>>, TError,{data: DataSourceCreate}, TContext> => {

const mutationKey = ['createDataSourceApiV1DatasourcesPost'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createDataSourceApiV1DatasourcesPost>>, {data: DataSourceCreate}> = (props) => {
          const {data} = props ?? {};

          return  createDataSourceApiV1DatasourcesPost(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateDataSourceApiV1DatasourcesPostMutationResult = NonNullable<Awaited<ReturnType<typeof createDataSourceApiV1DatasourcesPost>>>
    export type CreateDataSourceApiV1DatasourcesPostMutationBody = DataSourceCreate
    export type CreateDataSourceApiV1DatasourcesPostMutationError = HTTPValidationError

    /**
 * @summary Create Data Source
 */
export const useCreateDataSourceApiV1DatasourcesPost = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createDataSourceApiV1DatasourcesPost>>, TError,{data: DataSourceCreate}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createDataSourceApiV1DatasourcesPost>>,
        TError,
        {data: DataSourceCreate},
        TContext
      > => {

      const mutationOptions = getCreateDataSourceApiV1DatasourcesPostMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * List all data sources with mappings loaded.
 * @summary List Data Sources
 */
export const listDataSourcesApiV1DatasourcesGet = (
    params?: ListDataSourcesApiV1DatasourcesGetParams,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<DataSourceResponse[]>(
      {url: `/api/v1/datasources`, method: 'GET',
        params, signal
    },
      options);
    }
  



export const getListDataSourcesApiV1DatasourcesGetQueryKey = (params?: ListDataSourcesApiV1DatasourcesGetParams,) => {
    return [
    `/api/v1/datasources`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getListDataSourcesApiV1DatasourcesGetQueryOptions = <TData = Awaited<ReturnType<typeof listDataSourcesApiV1DatasourcesGet>>, TError = HTTPValidationError>(params?: ListDataSourcesApiV1DatasourcesGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listDataSourcesApiV1DatasourcesGet>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getListDataSourcesApiV1DatasourcesGetQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof listDataSourcesApiV1DatasourcesGet>>> = ({ signal }) => listDataSourcesApiV1DatasourcesGet(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof listDataSourcesApiV1DatasourcesGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ListDataSourcesApiV1DatasourcesGetQueryResult = NonNullable<Awaited<ReturnType<typeof listDataSourcesApiV1DatasourcesGet>>>
export type ListDataSourcesApiV1DatasourcesGetQueryError = HTTPValidationError


export function useListDataSourcesApiV1DatasourcesGet<TData = Awaited<ReturnType<typeof listDataSourcesApiV1DatasourcesGet>>, TError = HTTPValidationError>(
 params: undefined |  ListDataSourcesApiV1DatasourcesGetParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof listDataSourcesApiV1DatasourcesGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof listDataSourcesApiV1DatasourcesGet>>,
          TError,
          Awaited<ReturnType<typeof listDataSourcesApiV1DatasourcesGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useListDataSourcesApiV1DatasourcesGet<TData = Awaited<ReturnType<typeof listDataSourcesApiV1DatasourcesGet>>, TError = HTTPValidationError>(
 params?: ListDataSourcesApiV1DatasourcesGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listDataSourcesApiV1DatasourcesGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof listDataSourcesApiV1DatasourcesGet>>,
          TError,
          Awaited<ReturnType<typeof listDataSourcesApiV1DatasourcesGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useListDataSourcesApiV1DatasourcesGet<TData = Awaited<ReturnType<typeof listDataSourcesApiV1DatasourcesGet>>, TError = HTTPValidationError>(
 params?: ListDataSourcesApiV1DatasourcesGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listDataSourcesApiV1DatasourcesGet>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary List Data Sources
 */

export function useListDataSourcesApiV1DatasourcesGet<TData = Awaited<ReturnType<typeof listDataSourcesApiV1DatasourcesGet>>, TError = HTTPValidationError>(
 params?: ListDataSourcesApiV1DatasourcesGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listDataSourcesApiV1DatasourcesGet>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getListDataSourcesApiV1DatasourcesGetQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * Get data source by ID.
 * @summary Get Data Source
 */
export const getDataSourceApiV1DatasourcesDataSourceIdGet = (
    dataSourceId: string,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<DataSourceResponse>(
      {url: `/api/v1/datasources/${dataSourceId}`, method: 'GET', signal
    },
      options);
    }
  



export const getGetDataSourceApiV1DatasourcesDataSourceIdGetQueryKey = (dataSourceId?: string,) => {
    return [
    `/api/v1/datasources/${dataSourceId}`
    ] as const;
    }

    
export const getGetDataSourceApiV1DatasourcesDataSourceIdGetQueryOptions = <TData = Awaited<ReturnType<typeof getDataSourceApiV1DatasourcesDataSourceIdGet>>, TError = HTTPValidationError>(dataSourceId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDataSourceApiV1DatasourcesDataSourceIdGet>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetDataSourceApiV1DatasourcesDataSourceIdGetQueryKey(dataSourceId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getDataSourceApiV1DatasourcesDataSourceIdGet>>> = ({ signal }) => getDataSourceApiV1DatasourcesDataSourceIdGet(dataSourceId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(dataSourceId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getDataSourceApiV1DatasourcesDataSourceIdGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetDataSourceApiV1DatasourcesDataSourceIdGetQueryResult = NonNullable<Awaited<ReturnType<typeof getDataSourceApiV1DatasourcesDataSourceIdGet>>>
export type GetDataSourceApiV1DatasourcesDataSourceIdGetQueryError = HTTPValidationError


export function useGetDataSourceApiV1DatasourcesDataSourceIdGet<TData = Awaited<ReturnType<typeof getDataSourceApiV1DatasourcesDataSourceIdGet>>, TError = HTTPValidationError>(
 dataSourceId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDataSourceApiV1DatasourcesDataSourceIdGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDataSourceApiV1DatasourcesDataSourceIdGet>>,
          TError,
          Awaited<ReturnType<typeof getDataSourceApiV1DatasourcesDataSourceIdGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetDataSourceApiV1DatasourcesDataSourceIdGet<TData = Awaited<ReturnType<typeof getDataSourceApiV1DatasourcesDataSourceIdGet>>, TError = HTTPValidationError>(
 dataSourceId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDataSourceApiV1DatasourcesDataSourceIdGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDataSourceApiV1DatasourcesDataSourceIdGet>>,
          TError,
          Awaited<ReturnType<typeof getDataSourceApiV1DatasourcesDataSourceIdGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetDataSourceApiV1DatasourcesDataSourceIdGet<TData = Awaited<ReturnType<typeof getDataSourceApiV1DatasourcesDataSourceIdGet>>, TError = HTTPValidationError>(
 dataSourceId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDataSourceApiV1DatasourcesDataSourceIdGet>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Data Source
 */

export function useGetDataSourceApiV1DatasourcesDataSourceIdGet<TData = Awaited<ReturnType<typeof getDataSourceApiV1DatasourcesDataSourceIdGet>>, TError = HTTPValidationError>(
 dataSourceId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDataSourceApiV1DatasourcesDataSourceIdGet>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetDataSourceApiV1DatasourcesDataSourceIdGetQueryOptions(dataSourceId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * Update mappings or time column for a specific DataSource.
 * @summary Update Data Source
 */
export const updateDataSourceApiV1DatasourcesDataSourceIdPut = (
    dataSourceId: string,
    dataSourceUpdate: DataSourceUpdate,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<DataSourceResponse>(
      {url: `/api/v1/datasources/${dataSourceId}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: dataSourceUpdate
    },
      options);
    }
  


export const getUpdateDataSourceApiV1DatasourcesDataSourceIdPutMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateDataSourceApiV1DatasourcesDataSourceIdPut>>, TError,{dataSourceId: string;data: DataSourceUpdate}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof updateDataSourceApiV1DatasourcesDataSourceIdPut>>, TError,{dataSourceId: string;data: DataSourceUpdate}, TContext> => {

const mutationKey = ['updateDataSourceApiV1DatasourcesDataSourceIdPut'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateDataSourceApiV1DatasourcesDataSourceIdPut>>, {dataSourceId: string;data: DataSourceUpdate}> = (props) => {
          const {dataSourceId,data} = props ?? {};

          return  updateDataSourceApiV1DatasourcesDataSourceIdPut(dataSourceId,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateDataSourceApiV1DatasourcesDataSourceIdPutMutationResult = NonNullable<Awaited<ReturnType<typeof updateDataSourceApiV1DatasourcesDataSourceIdPut>>>
    export type UpdateDataSourceApiV1DatasourcesDataSourceIdPutMutationBody = DataSourceUpdate
    export type UpdateDataSourceApiV1DatasourcesDataSourceIdPutMutationError = HTTPValidationError

    /**
 * @summary Update Data Source
 */
export const useUpdateDataSourceApiV1DatasourcesDataSourceIdPut = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateDataSourceApiV1DatasourcesDataSourceIdPut>>, TError,{dataSourceId: string;data: DataSourceUpdate}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateDataSourceApiV1DatasourcesDataSourceIdPut>>,
        TError,
        {dataSourceId: string;data: DataSourceUpdate},
        TContext
      > => {

      const mutationOptions = getUpdateDataSourceApiV1DatasourcesDataSourceIdPutMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Delete a data source and all its associated schema mappings.
The database cascade should handle the mappings, but we'll be explicit if needed.
 * @summary Delete Data Source
 */
export const deleteDataSourceApiV1DatasourcesDataSourceIdDelete = (
    dataSourceId: string,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<void>(
      {url: `/api/v1/datasources/${dataSourceId}`, method: 'DELETE'
    },
      options);
    }
  


export const getDeleteDataSourceApiV1DatasourcesDataSourceIdDeleteMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteDataSourceApiV1DatasourcesDataSourceIdDelete>>, TError,{dataSourceId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof deleteDataSourceApiV1DatasourcesDataSourceIdDelete>>, TError,{dataSourceId: string}, TContext> => {

const mutationKey = ['deleteDataSourceApiV1DatasourcesDataSourceIdDelete'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteDataSourceApiV1DatasourcesDataSourceIdDelete>>, {dataSourceId: string}> = (props) => {
          const {dataSourceId} = props ?? {};

          return  deleteDataSourceApiV1DatasourcesDataSourceIdDelete(dataSourceId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteDataSourceApiV1DatasourcesDataSourceIdDeleteMutationResult = NonNullable<Awaited<ReturnType<typeof deleteDataSourceApiV1DatasourcesDataSourceIdDelete>>>
    
    export type DeleteDataSourceApiV1DatasourcesDataSourceIdDeleteMutationError = HTTPValidationError

    /**
 * @summary Delete Data Source
 */
export const useDeleteDataSourceApiV1DatasourcesDataSourceIdDelete = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteDataSourceApiV1DatasourcesDataSourceIdDelete>>, TError,{dataSourceId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteDataSourceApiV1DatasourcesDataSourceIdDelete>>,
        TError,
        {dataSourceId: string},
        TContext
      > => {

      const mutationOptions = getDeleteDataSourceApiV1DatasourcesDataSourceIdDeleteMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Get data source for a specific production line.
 * @summary Get Data Source By Line
 */
export const getDataSourceByLineApiV1DatasourcesLineLineIdGet = (
    lineId: string,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<GetDataSourceByLineApiV1DatasourcesLineLineIdGet200>(
      {url: `/api/v1/datasources/line/${lineId}`, method: 'GET', signal
    },
      options);
    }
  



export const getGetDataSourceByLineApiV1DatasourcesLineLineIdGetQueryKey = (lineId?: string,) => {
    return [
    `/api/v1/datasources/line/${lineId}`
    ] as const;
    }

    
export const getGetDataSourceByLineApiV1DatasourcesLineLineIdGetQueryOptions = <TData = Awaited<ReturnType<typeof getDataSourceByLineApiV1DatasourcesLineLineIdGet>>, TError = HTTPValidationError>(lineId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDataSourceByLineApiV1DatasourcesLineLineIdGet>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetDataSourceByLineApiV1DatasourcesLineLineIdGetQueryKey(lineId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getDataSourceByLineApiV1DatasourcesLineLineIdGet>>> = ({ signal }) => getDataSourceByLineApiV1DatasourcesLineLineIdGet(lineId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(lineId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getDataSourceByLineApiV1DatasourcesLineLineIdGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetDataSourceByLineApiV1DatasourcesLineLineIdGetQueryResult = NonNullable<Awaited<ReturnType<typeof getDataSourceByLineApiV1DatasourcesLineLineIdGet>>>
export type GetDataSourceByLineApiV1DatasourcesLineLineIdGetQueryError = HTTPValidationError


export function useGetDataSourceByLineApiV1DatasourcesLineLineIdGet<TData = Awaited<ReturnType<typeof getDataSourceByLineApiV1DatasourcesLineLineIdGet>>, TError = HTTPValidationError>(
 lineId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDataSourceByLineApiV1DatasourcesLineLineIdGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDataSourceByLineApiV1DatasourcesLineLineIdGet>>,
          TError,
          Awaited<ReturnType<typeof getDataSourceByLineApiV1DatasourcesLineLineIdGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetDataSourceByLineApiV1DatasourcesLineLineIdGet<TData = Awaited<ReturnType<typeof getDataSourceByLineApiV1DatasourcesLineLineIdGet>>, TError = HTTPValidationError>(
 lineId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDataSourceByLineApiV1DatasourcesLineLineIdGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDataSourceByLineApiV1DatasourcesLineLineIdGet>>,
          TError,
          Awaited<ReturnType<typeof getDataSourceByLineApiV1DatasourcesLineLineIdGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetDataSourceByLineApiV1DatasourcesLineLineIdGet<TData = Awaited<ReturnType<typeof getDataSourceByLineApiV1DatasourcesLineLineIdGet>>, TError = HTTPValidationError>(
 lineId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDataSourceByLineApiV1DatasourcesLineLineIdGet>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Data Source By Line
 */

export function useGetDataSourceByLineApiV1DatasourcesLineLineIdGet<TData = Awaited<ReturnType<typeof getDataSourceByLineApiV1DatasourcesLineLineIdGet>>, TError = HTTPValidationError>(
 lineId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDataSourceByLineApiV1DatasourcesLineLineIdGet>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetDataSourceByLineApiV1DatasourcesLineLineIdGetQueryOptions(lineId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * Fetch DataSource config for a specific line.
Returns 200 with null if not found (graceful init).
Alias/Explicit endpoint for validate-mapping flow.
 * @summary Get Datasource By Line Explicit
 */
export const getDatasourceByLineExplicitApiV1DatasourcesByLineProductionLineIdGet = (
    productionLineId: string,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<GetDatasourceByLineExplicitApiV1DatasourcesByLineProductionLineIdGet200>(
      {url: `/api/v1/datasources/by-line/${productionLineId}`, method: 'GET', signal
    },
      options);
    }
  



export const getGetDatasourceByLineExplicitApiV1DatasourcesByLineProductionLineIdGetQueryKey = (productionLineId?: string,) => {
    return [
    `/api/v1/datasources/by-line/${productionLineId}`
    ] as const;
    }

    
export const getGetDatasourceByLineExplicitApiV1DatasourcesByLineProductionLineIdGetQueryOptions = <TData = Awaited<ReturnType<typeof getDatasourceByLineExplicitApiV1DatasourcesByLineProductionLineIdGet>>, TError = HTTPValidationError>(productionLineId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDatasourceByLineExplicitApiV1DatasourcesByLineProductionLineIdGet>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetDatasourceByLineExplicitApiV1DatasourcesByLineProductionLineIdGetQueryKey(productionLineId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getDatasourceByLineExplicitApiV1DatasourcesByLineProductionLineIdGet>>> = ({ signal }) => getDatasourceByLineExplicitApiV1DatasourcesByLineProductionLineIdGet(productionLineId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(productionLineId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getDatasourceByLineExplicitApiV1DatasourcesByLineProductionLineIdGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetDatasourceByLineExplicitApiV1DatasourcesByLineProductionLineIdGetQueryResult = NonNullable<Awaited<ReturnType<typeof getDatasourceByLineExplicitApiV1DatasourcesByLineProductionLineIdGet>>>
export type GetDatasourceByLineExplicitApiV1DatasourcesByLineProductionLineIdGetQueryError = HTTPValidationError


export function useGetDatasourceByLineExplicitApiV1DatasourcesByLineProductionLineIdGet<TData = Awaited<ReturnType<typeof getDatasourceByLineExplicitApiV1DatasourcesByLineProductionLineIdGet>>, TError = HTTPValidationError>(
 productionLineId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDatasourceByLineExplicitApiV1DatasourcesByLineProductionLineIdGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDatasourceByLineExplicitApiV1DatasourcesByLineProductionLineIdGet>>,
          TError,
          Awaited<ReturnType<typeof getDatasourceByLineExplicitApiV1DatasourcesByLineProductionLineIdGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetDatasourceByLineExplicitApiV1DatasourcesByLineProductionLineIdGet<TData = Awaited<ReturnType<typeof getDatasourceByLineExplicitApiV1DatasourcesByLineProductionLineIdGet>>, TError = HTTPValidationError>(
 productionLineId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDatasourceByLineExplicitApiV1DatasourcesByLineProductionLineIdGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDatasourceByLineExplicitApiV1DatasourcesByLineProductionLineIdGet>>,
          TError,
          Awaited<ReturnType<typeof getDatasourceByLineExplicitApiV1DatasourcesByLineProductionLineIdGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetDatasourceByLineExplicitApiV1DatasourcesByLineProductionLineIdGet<TData = Awaited<ReturnType<typeof getDatasourceByLineExplicitApiV1DatasourcesByLineProductionLineIdGet>>, TError = HTTPValidationError>(
 productionLineId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDatasourceByLineExplicitApiV1DatasourcesByLineProductionLineIdGet>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Datasource By Line Explicit
 */

export function useGetDatasourceByLineExplicitApiV1DatasourcesByLineProductionLineIdGet<TData = Awaited<ReturnType<typeof getDatasourceByLineExplicitApiV1DatasourcesByLineProductionLineIdGet>>, TError = HTTPValidationError>(
 productionLineId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDatasourceByLineExplicitApiV1DatasourcesByLineProductionLineIdGet>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetDatasourceByLineExplicitApiV1DatasourcesByLineProductionLineIdGetQueryOptions(productionLineId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * Create a new version of the schema mapping after user validation.
 * @summary Update Schema Mapping
 */
export const updateSchemaMappingApiV1DatasourcesDataSourceIdMappingPut = (
    dataSourceId: string,
    schemaMappingCreate: SchemaMappingCreate,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<SchemaMappingResponse>(
      {url: `/api/v1/datasources/${dataSourceId}/mapping`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: schemaMappingCreate
    },
      options);
    }
  


export const getUpdateSchemaMappingApiV1DatasourcesDataSourceIdMappingPutMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateSchemaMappingApiV1DatasourcesDataSourceIdMappingPut>>, TError,{dataSourceId: string;data: SchemaMappingCreate}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof updateSchemaMappingApiV1DatasourcesDataSourceIdMappingPut>>, TError,{dataSourceId: string;data: SchemaMappingCreate}, TContext> => {

const mutationKey = ['updateSchemaMappingApiV1DatasourcesDataSourceIdMappingPut'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateSchemaMappingApiV1DatasourcesDataSourceIdMappingPut>>, {dataSourceId: string;data: SchemaMappingCreate}> = (props) => {
          const {dataSourceId,data} = props ?? {};

          return  updateSchemaMappingApiV1DatasourcesDataSourceIdMappingPut(dataSourceId,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateSchemaMappingApiV1DatasourcesDataSourceIdMappingPutMutationResult = NonNullable<Awaited<ReturnType<typeof updateSchemaMappingApiV1DatasourcesDataSourceIdMappingPut>>>
    export type UpdateSchemaMappingApiV1DatasourcesDataSourceIdMappingPutMutationBody = SchemaMappingCreate
    export type UpdateSchemaMappingApiV1DatasourcesDataSourceIdMappingPutMutationError = HTTPValidationError

    /**
 * @summary Update Schema Mapping
 */
export const useUpdateSchemaMappingApiV1DatasourcesDataSourceIdMappingPut = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateSchemaMappingApiV1DatasourcesDataSourceIdMappingPut>>, TError,{dataSourceId: string;data: SchemaMappingCreate}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateSchemaMappingApiV1DatasourcesDataSourceIdMappingPut>>,
        TError,
        {dataSourceId: string;data: SchemaMappingCreate},
        TContext
      > => {

      const mutationOptions = getUpdateSchemaMappingApiV1DatasourcesDataSourceIdMappingPutMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    