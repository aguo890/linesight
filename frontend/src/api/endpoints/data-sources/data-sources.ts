/*
 * Copyright (c) 2026 Aaron Guo. All rights reserved.
 * Use of this source code is governed by the proprietary license
 * found in the LICENSE file in the root directory of this source tree.
 */

/**
 * Generated by orval v7.13.2 üç∫
 * Do not edit manually.
 * LineSight
 * LineSight: AI-driven Semantic ETL platform for SMB apparel manufacturing. Parse messy Excel files, track SAM/DHU metrics, and ensure UFLPA compliance.
 * OpenAPI spec version: 0.1.0
 */
import {
  useMutation,
  useQuery
} from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import type {
  AppApiV1EndpointsDatasourceDataSourceCreate,
  AppApiV1EndpointsDatasourceDataSourceUpdate,
  DataSourceResponse,
  GetDataSourceByLineApiV1DataSourcesLineLineIdGet200,
  GetDatasourceByLineExplicitApiV1DataSourcesByLineProductionLineIdGet200,
  HTTPValidationError,
  ListDataSourcesApiV1DataSourcesGetParams,
  SchemaMappingCreate,
  SchemaMappingResponse
} from '../../model';

import { customInstance } from '../../axios-client';


type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];



/**
 * Create a new data source for a production line.
 * @summary Create Data Source
 */
export const createDataSourceApiV1DataSourcesPost = (
    appApiV1EndpointsDatasourceDataSourceCreate: AppApiV1EndpointsDatasourceDataSourceCreate,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<DataSourceResponse>(
      {url: `/api/v1/data-sources`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: appApiV1EndpointsDatasourceDataSourceCreate, signal
    },
      options);
    }
  


export const getCreateDataSourceApiV1DataSourcesPostMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createDataSourceApiV1DataSourcesPost>>, TError,{data: AppApiV1EndpointsDatasourceDataSourceCreate}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof createDataSourceApiV1DataSourcesPost>>, TError,{data: AppApiV1EndpointsDatasourceDataSourceCreate}, TContext> => {

const mutationKey = ['createDataSourceApiV1DataSourcesPost'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createDataSourceApiV1DataSourcesPost>>, {data: AppApiV1EndpointsDatasourceDataSourceCreate}> = (props) => {
          const {data} = props ?? {};

          return  createDataSourceApiV1DataSourcesPost(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateDataSourceApiV1DataSourcesPostMutationResult = NonNullable<Awaited<ReturnType<typeof createDataSourceApiV1DataSourcesPost>>>
    export type CreateDataSourceApiV1DataSourcesPostMutationBody = AppApiV1EndpointsDatasourceDataSourceCreate
    export type CreateDataSourceApiV1DataSourcesPostMutationError = HTTPValidationError

    /**
 * @summary Create Data Source
 */
export const useCreateDataSourceApiV1DataSourcesPost = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createDataSourceApiV1DataSourcesPost>>, TError,{data: AppApiV1EndpointsDatasourceDataSourceCreate}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createDataSourceApiV1DataSourcesPost>>,
        TError,
        {data: AppApiV1EndpointsDatasourceDataSourceCreate},
        TContext
      > => {

      const mutationOptions = getCreateDataSourceApiV1DataSourcesPostMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * List all data sources with mappings loaded.
 * @summary List Data Sources
 */
export const listDataSourcesApiV1DataSourcesGet = (
    params?: ListDataSourcesApiV1DataSourcesGetParams,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<DataSourceResponse[]>(
      {url: `/api/v1/data-sources`, method: 'GET',
        params, signal
    },
      options);
    }
  



export const getListDataSourcesApiV1DataSourcesGetQueryKey = (params?: ListDataSourcesApiV1DataSourcesGetParams,) => {
    return [
    `/api/v1/data-sources`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getListDataSourcesApiV1DataSourcesGetQueryOptions = <TData = Awaited<ReturnType<typeof listDataSourcesApiV1DataSourcesGet>>, TError = HTTPValidationError>(params?: ListDataSourcesApiV1DataSourcesGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listDataSourcesApiV1DataSourcesGet>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getListDataSourcesApiV1DataSourcesGetQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof listDataSourcesApiV1DataSourcesGet>>> = ({ signal }) => listDataSourcesApiV1DataSourcesGet(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof listDataSourcesApiV1DataSourcesGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ListDataSourcesApiV1DataSourcesGetQueryResult = NonNullable<Awaited<ReturnType<typeof listDataSourcesApiV1DataSourcesGet>>>
export type ListDataSourcesApiV1DataSourcesGetQueryError = HTTPValidationError


export function useListDataSourcesApiV1DataSourcesGet<TData = Awaited<ReturnType<typeof listDataSourcesApiV1DataSourcesGet>>, TError = HTTPValidationError>(
 params: undefined |  ListDataSourcesApiV1DataSourcesGetParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof listDataSourcesApiV1DataSourcesGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof listDataSourcesApiV1DataSourcesGet>>,
          TError,
          Awaited<ReturnType<typeof listDataSourcesApiV1DataSourcesGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useListDataSourcesApiV1DataSourcesGet<TData = Awaited<ReturnType<typeof listDataSourcesApiV1DataSourcesGet>>, TError = HTTPValidationError>(
 params?: ListDataSourcesApiV1DataSourcesGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listDataSourcesApiV1DataSourcesGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof listDataSourcesApiV1DataSourcesGet>>,
          TError,
          Awaited<ReturnType<typeof listDataSourcesApiV1DataSourcesGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useListDataSourcesApiV1DataSourcesGet<TData = Awaited<ReturnType<typeof listDataSourcesApiV1DataSourcesGet>>, TError = HTTPValidationError>(
 params?: ListDataSourcesApiV1DataSourcesGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listDataSourcesApiV1DataSourcesGet>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary List Data Sources
 */

export function useListDataSourcesApiV1DataSourcesGet<TData = Awaited<ReturnType<typeof listDataSourcesApiV1DataSourcesGet>>, TError = HTTPValidationError>(
 params?: ListDataSourcesApiV1DataSourcesGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listDataSourcesApiV1DataSourcesGet>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getListDataSourcesApiV1DataSourcesGetQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * Get data source by ID.
 * @summary Get Data Source
 */
export const getDataSourceApiV1DataSourcesDataSourceIdGet = (
    dataSourceId: string,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<DataSourceResponse>(
      {url: `/api/v1/data-sources/${dataSourceId}`, method: 'GET', signal
    },
      options);
    }
  



export const getGetDataSourceApiV1DataSourcesDataSourceIdGetQueryKey = (dataSourceId?: string,) => {
    return [
    `/api/v1/data-sources/${dataSourceId}`
    ] as const;
    }

    
export const getGetDataSourceApiV1DataSourcesDataSourceIdGetQueryOptions = <TData = Awaited<ReturnType<typeof getDataSourceApiV1DataSourcesDataSourceIdGet>>, TError = HTTPValidationError>(dataSourceId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDataSourceApiV1DataSourcesDataSourceIdGet>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetDataSourceApiV1DataSourcesDataSourceIdGetQueryKey(dataSourceId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getDataSourceApiV1DataSourcesDataSourceIdGet>>> = ({ signal }) => getDataSourceApiV1DataSourcesDataSourceIdGet(dataSourceId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(dataSourceId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getDataSourceApiV1DataSourcesDataSourceIdGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetDataSourceApiV1DataSourcesDataSourceIdGetQueryResult = NonNullable<Awaited<ReturnType<typeof getDataSourceApiV1DataSourcesDataSourceIdGet>>>
export type GetDataSourceApiV1DataSourcesDataSourceIdGetQueryError = HTTPValidationError


export function useGetDataSourceApiV1DataSourcesDataSourceIdGet<TData = Awaited<ReturnType<typeof getDataSourceApiV1DataSourcesDataSourceIdGet>>, TError = HTTPValidationError>(
 dataSourceId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDataSourceApiV1DataSourcesDataSourceIdGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDataSourceApiV1DataSourcesDataSourceIdGet>>,
          TError,
          Awaited<ReturnType<typeof getDataSourceApiV1DataSourcesDataSourceIdGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetDataSourceApiV1DataSourcesDataSourceIdGet<TData = Awaited<ReturnType<typeof getDataSourceApiV1DataSourcesDataSourceIdGet>>, TError = HTTPValidationError>(
 dataSourceId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDataSourceApiV1DataSourcesDataSourceIdGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDataSourceApiV1DataSourcesDataSourceIdGet>>,
          TError,
          Awaited<ReturnType<typeof getDataSourceApiV1DataSourcesDataSourceIdGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetDataSourceApiV1DataSourcesDataSourceIdGet<TData = Awaited<ReturnType<typeof getDataSourceApiV1DataSourcesDataSourceIdGet>>, TError = HTTPValidationError>(
 dataSourceId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDataSourceApiV1DataSourcesDataSourceIdGet>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Data Source
 */

export function useGetDataSourceApiV1DataSourcesDataSourceIdGet<TData = Awaited<ReturnType<typeof getDataSourceApiV1DataSourcesDataSourceIdGet>>, TError = HTTPValidationError>(
 dataSourceId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDataSourceApiV1DataSourcesDataSourceIdGet>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetDataSourceApiV1DataSourcesDataSourceIdGetQueryOptions(dataSourceId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * Update mappings or time column for a specific DataSource.
 * @summary Update Data Source
 */
export const updateDataSourceApiV1DataSourcesDataSourceIdPut = (
    dataSourceId: string,
    appApiV1EndpointsDatasourceDataSourceUpdate: AppApiV1EndpointsDatasourceDataSourceUpdate,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<DataSourceResponse>(
      {url: `/api/v1/data-sources/${dataSourceId}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: appApiV1EndpointsDatasourceDataSourceUpdate
    },
      options);
    }
  


export const getUpdateDataSourceApiV1DataSourcesDataSourceIdPutMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateDataSourceApiV1DataSourcesDataSourceIdPut>>, TError,{dataSourceId: string;data: AppApiV1EndpointsDatasourceDataSourceUpdate}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof updateDataSourceApiV1DataSourcesDataSourceIdPut>>, TError,{dataSourceId: string;data: AppApiV1EndpointsDatasourceDataSourceUpdate}, TContext> => {

const mutationKey = ['updateDataSourceApiV1DataSourcesDataSourceIdPut'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateDataSourceApiV1DataSourcesDataSourceIdPut>>, {dataSourceId: string;data: AppApiV1EndpointsDatasourceDataSourceUpdate}> = (props) => {
          const {dataSourceId,data} = props ?? {};

          return  updateDataSourceApiV1DataSourcesDataSourceIdPut(dataSourceId,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateDataSourceApiV1DataSourcesDataSourceIdPutMutationResult = NonNullable<Awaited<ReturnType<typeof updateDataSourceApiV1DataSourcesDataSourceIdPut>>>
    export type UpdateDataSourceApiV1DataSourcesDataSourceIdPutMutationBody = AppApiV1EndpointsDatasourceDataSourceUpdate
    export type UpdateDataSourceApiV1DataSourcesDataSourceIdPutMutationError = HTTPValidationError

    /**
 * @summary Update Data Source
 */
export const useUpdateDataSourceApiV1DataSourcesDataSourceIdPut = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateDataSourceApiV1DataSourcesDataSourceIdPut>>, TError,{dataSourceId: string;data: AppApiV1EndpointsDatasourceDataSourceUpdate}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateDataSourceApiV1DataSourcesDataSourceIdPut>>,
        TError,
        {dataSourceId: string;data: AppApiV1EndpointsDatasourceDataSourceUpdate},
        TContext
      > => {

      const mutationOptions = getUpdateDataSourceApiV1DataSourcesDataSourceIdPutMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Delete a data source and all its associated schema mappings.
 * @summary Delete Data Source
 */
export const deleteDataSourceApiV1DataSourcesDataSourceIdDelete = (
    dataSourceId: string,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<void>(
      {url: `/api/v1/data-sources/${dataSourceId}`, method: 'DELETE'
    },
      options);
    }
  


export const getDeleteDataSourceApiV1DataSourcesDataSourceIdDeleteMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteDataSourceApiV1DataSourcesDataSourceIdDelete>>, TError,{dataSourceId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof deleteDataSourceApiV1DataSourcesDataSourceIdDelete>>, TError,{dataSourceId: string}, TContext> => {

const mutationKey = ['deleteDataSourceApiV1DataSourcesDataSourceIdDelete'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteDataSourceApiV1DataSourcesDataSourceIdDelete>>, {dataSourceId: string}> = (props) => {
          const {dataSourceId} = props ?? {};

          return  deleteDataSourceApiV1DataSourcesDataSourceIdDelete(dataSourceId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteDataSourceApiV1DataSourcesDataSourceIdDeleteMutationResult = NonNullable<Awaited<ReturnType<typeof deleteDataSourceApiV1DataSourcesDataSourceIdDelete>>>
    
    export type DeleteDataSourceApiV1DataSourcesDataSourceIdDeleteMutationError = HTTPValidationError

    /**
 * @summary Delete Data Source
 */
export const useDeleteDataSourceApiV1DataSourcesDataSourceIdDelete = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteDataSourceApiV1DataSourcesDataSourceIdDelete>>, TError,{dataSourceId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteDataSourceApiV1DataSourcesDataSourceIdDelete>>,
        TError,
        {dataSourceId: string},
        TContext
      > => {

      const mutationOptions = getDeleteDataSourceApiV1DataSourcesDataSourceIdDeleteMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Get data source by ID (line_id IS the DataSource.id after refactor).
 * @summary Get Data Source By Line
 */
export const getDataSourceByLineApiV1DataSourcesLineLineIdGet = (
    lineId: string,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<GetDataSourceByLineApiV1DataSourcesLineLineIdGet200>(
      {url: `/api/v1/data-sources/line/${lineId}`, method: 'GET', signal
    },
      options);
    }
  



export const getGetDataSourceByLineApiV1DataSourcesLineLineIdGetQueryKey = (lineId?: string,) => {
    return [
    `/api/v1/data-sources/line/${lineId}`
    ] as const;
    }

    
export const getGetDataSourceByLineApiV1DataSourcesLineLineIdGetQueryOptions = <TData = Awaited<ReturnType<typeof getDataSourceByLineApiV1DataSourcesLineLineIdGet>>, TError = HTTPValidationError>(lineId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDataSourceByLineApiV1DataSourcesLineLineIdGet>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetDataSourceByLineApiV1DataSourcesLineLineIdGetQueryKey(lineId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getDataSourceByLineApiV1DataSourcesLineLineIdGet>>> = ({ signal }) => getDataSourceByLineApiV1DataSourcesLineLineIdGet(lineId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(lineId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getDataSourceByLineApiV1DataSourcesLineLineIdGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetDataSourceByLineApiV1DataSourcesLineLineIdGetQueryResult = NonNullable<Awaited<ReturnType<typeof getDataSourceByLineApiV1DataSourcesLineLineIdGet>>>
export type GetDataSourceByLineApiV1DataSourcesLineLineIdGetQueryError = HTTPValidationError


export function useGetDataSourceByLineApiV1DataSourcesLineLineIdGet<TData = Awaited<ReturnType<typeof getDataSourceByLineApiV1DataSourcesLineLineIdGet>>, TError = HTTPValidationError>(
 lineId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDataSourceByLineApiV1DataSourcesLineLineIdGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDataSourceByLineApiV1DataSourcesLineLineIdGet>>,
          TError,
          Awaited<ReturnType<typeof getDataSourceByLineApiV1DataSourcesLineLineIdGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetDataSourceByLineApiV1DataSourcesLineLineIdGet<TData = Awaited<ReturnType<typeof getDataSourceByLineApiV1DataSourcesLineLineIdGet>>, TError = HTTPValidationError>(
 lineId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDataSourceByLineApiV1DataSourcesLineLineIdGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDataSourceByLineApiV1DataSourcesLineLineIdGet>>,
          TError,
          Awaited<ReturnType<typeof getDataSourceByLineApiV1DataSourcesLineLineIdGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetDataSourceByLineApiV1DataSourcesLineLineIdGet<TData = Awaited<ReturnType<typeof getDataSourceByLineApiV1DataSourcesLineLineIdGet>>, TError = HTTPValidationError>(
 lineId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDataSourceByLineApiV1DataSourcesLineLineIdGet>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Data Source By Line
 */

export function useGetDataSourceByLineApiV1DataSourcesLineLineIdGet<TData = Awaited<ReturnType<typeof getDataSourceByLineApiV1DataSourcesLineLineIdGet>>, TError = HTTPValidationError>(
 lineId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDataSourceByLineApiV1DataSourcesLineLineIdGet>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetDataSourceByLineApiV1DataSourcesLineLineIdGetQueryOptions(lineId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * Fetch DataSource config for a specific line.
Returns 200 with null if not found (graceful init).
After refactor: production_line_id IS the DataSource.id directly.
 * @summary Get Datasource By Line Explicit
 */
export const getDatasourceByLineExplicitApiV1DataSourcesByLineProductionLineIdGet = (
    productionLineId: string,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<GetDatasourceByLineExplicitApiV1DataSourcesByLineProductionLineIdGet200>(
      {url: `/api/v1/data-sources/by-line/${productionLineId}`, method: 'GET', signal
    },
      options);
    }
  



export const getGetDatasourceByLineExplicitApiV1DataSourcesByLineProductionLineIdGetQueryKey = (productionLineId?: string,) => {
    return [
    `/api/v1/data-sources/by-line/${productionLineId}`
    ] as const;
    }

    
export const getGetDatasourceByLineExplicitApiV1DataSourcesByLineProductionLineIdGetQueryOptions = <TData = Awaited<ReturnType<typeof getDatasourceByLineExplicitApiV1DataSourcesByLineProductionLineIdGet>>, TError = HTTPValidationError>(productionLineId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDatasourceByLineExplicitApiV1DataSourcesByLineProductionLineIdGet>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetDatasourceByLineExplicitApiV1DataSourcesByLineProductionLineIdGetQueryKey(productionLineId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getDatasourceByLineExplicitApiV1DataSourcesByLineProductionLineIdGet>>> = ({ signal }) => getDatasourceByLineExplicitApiV1DataSourcesByLineProductionLineIdGet(productionLineId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(productionLineId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getDatasourceByLineExplicitApiV1DataSourcesByLineProductionLineIdGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetDatasourceByLineExplicitApiV1DataSourcesByLineProductionLineIdGetQueryResult = NonNullable<Awaited<ReturnType<typeof getDatasourceByLineExplicitApiV1DataSourcesByLineProductionLineIdGet>>>
export type GetDatasourceByLineExplicitApiV1DataSourcesByLineProductionLineIdGetQueryError = HTTPValidationError


export function useGetDatasourceByLineExplicitApiV1DataSourcesByLineProductionLineIdGet<TData = Awaited<ReturnType<typeof getDatasourceByLineExplicitApiV1DataSourcesByLineProductionLineIdGet>>, TError = HTTPValidationError>(
 productionLineId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDatasourceByLineExplicitApiV1DataSourcesByLineProductionLineIdGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDatasourceByLineExplicitApiV1DataSourcesByLineProductionLineIdGet>>,
          TError,
          Awaited<ReturnType<typeof getDatasourceByLineExplicitApiV1DataSourcesByLineProductionLineIdGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetDatasourceByLineExplicitApiV1DataSourcesByLineProductionLineIdGet<TData = Awaited<ReturnType<typeof getDatasourceByLineExplicitApiV1DataSourcesByLineProductionLineIdGet>>, TError = HTTPValidationError>(
 productionLineId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDatasourceByLineExplicitApiV1DataSourcesByLineProductionLineIdGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDatasourceByLineExplicitApiV1DataSourcesByLineProductionLineIdGet>>,
          TError,
          Awaited<ReturnType<typeof getDatasourceByLineExplicitApiV1DataSourcesByLineProductionLineIdGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetDatasourceByLineExplicitApiV1DataSourcesByLineProductionLineIdGet<TData = Awaited<ReturnType<typeof getDatasourceByLineExplicitApiV1DataSourcesByLineProductionLineIdGet>>, TError = HTTPValidationError>(
 productionLineId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDatasourceByLineExplicitApiV1DataSourcesByLineProductionLineIdGet>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Datasource By Line Explicit
 */

export function useGetDatasourceByLineExplicitApiV1DataSourcesByLineProductionLineIdGet<TData = Awaited<ReturnType<typeof getDatasourceByLineExplicitApiV1DataSourcesByLineProductionLineIdGet>>, TError = HTTPValidationError>(
 productionLineId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDatasourceByLineExplicitApiV1DataSourcesByLineProductionLineIdGet>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetDatasourceByLineExplicitApiV1DataSourcesByLineProductionLineIdGetQueryOptions(productionLineId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * Create a new version of the schema mapping after user validation.
 * @summary Update Schema Mapping
 */
export const updateSchemaMappingApiV1DataSourcesDataSourceIdMappingPut = (
    dataSourceId: string,
    schemaMappingCreate: SchemaMappingCreate,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<SchemaMappingResponse>(
      {url: `/api/v1/data-sources/${dataSourceId}/mapping`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: schemaMappingCreate
    },
      options);
    }
  


export const getUpdateSchemaMappingApiV1DataSourcesDataSourceIdMappingPutMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateSchemaMappingApiV1DataSourcesDataSourceIdMappingPut>>, TError,{dataSourceId: string;data: SchemaMappingCreate}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof updateSchemaMappingApiV1DataSourcesDataSourceIdMappingPut>>, TError,{dataSourceId: string;data: SchemaMappingCreate}, TContext> => {

const mutationKey = ['updateSchemaMappingApiV1DataSourcesDataSourceIdMappingPut'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateSchemaMappingApiV1DataSourcesDataSourceIdMappingPut>>, {dataSourceId: string;data: SchemaMappingCreate}> = (props) => {
          const {dataSourceId,data} = props ?? {};

          return  updateSchemaMappingApiV1DataSourcesDataSourceIdMappingPut(dataSourceId,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateSchemaMappingApiV1DataSourcesDataSourceIdMappingPutMutationResult = NonNullable<Awaited<ReturnType<typeof updateSchemaMappingApiV1DataSourcesDataSourceIdMappingPut>>>
    export type UpdateSchemaMappingApiV1DataSourcesDataSourceIdMappingPutMutationBody = SchemaMappingCreate
    export type UpdateSchemaMappingApiV1DataSourcesDataSourceIdMappingPutMutationError = HTTPValidationError

    /**
 * @summary Update Schema Mapping
 */
export const useUpdateSchemaMappingApiV1DataSourcesDataSourceIdMappingPut = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateSchemaMappingApiV1DataSourcesDataSourceIdMappingPut>>, TError,{dataSourceId: string;data: SchemaMappingCreate}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateSchemaMappingApiV1DataSourcesDataSourceIdMappingPut>>,
        TError,
        {dataSourceId: string;data: SchemaMappingCreate},
        TContext
      > => {

      const mutationOptions = getUpdateSchemaMappingApiV1DataSourcesDataSourceIdMappingPutMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    