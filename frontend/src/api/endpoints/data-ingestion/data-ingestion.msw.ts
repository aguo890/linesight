/**
 * Generated by orval v7.13.2 ðŸº
 * Do not edit manually.
 * LineSight
 * LineSight: AI-driven Semantic ETL platform for SMB apparel manufacturing. Parse messy Excel files, track SAM/DHU metrics, and ensure UFLPA compliance.
 * OpenAPI spec version: 0.1.0
 */
import {
  faker
} from '@faker-js/faker';

import {
  HttpResponse,
  delay,
  http
} from 'msw';
import type {
  RequestHandlerOptions
} from 'msw';

import {
  MatchTier
} from '../../model';
import type {
  AvailableField,
  ConfirmMappingResponse,
  ProcessingResponse,
  PromoteToProductionApiV1IngestionPromoteRawImportIdPost200,
  UploadFileForIngestionApiV1IngestionUploadPost200
} from '../../model';


export const getUploadFileForIngestionApiV1IngestionUploadPostResponseMock = (): UploadFileForIngestionApiV1IngestionUploadPost200 => ({})

export const getProcessFileApiV1IngestionProcessRawImportIdPostResponseMock = (overrideResponse: Partial< ProcessingResponse > = {}): ProcessingResponse => ({raw_import_id: faker.string.alpha({length: {min: 10, max: 20}}), filename: faker.string.alpha({length: {min: 10, max: 20}}), columns: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({source_column: faker.string.alpha({length: {min: 10, max: 20}}), target_field: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}),null,]), undefined]), confidence: faker.number.float({min: 0, max: 1, fractionDigits: 2}), tier: faker.helpers.arrayElement(Object.values(MatchTier)), fuzzy_score: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.number.float({min: undefined, max: undefined, fractionDigits: 2}),null,]), undefined]), reasoning: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}),null,]), undefined]), sample_data: faker.helpers.arrayElement([Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({})), undefined]), needs_review: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), ignored: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), status: faker.string.alpha({length: {min: 10, max: 20}})})), stats: faker.helpers.arrayElement([{}, undefined]), auto_mapped_count: faker.number.int({min: undefined, max: undefined}), needs_review_count: faker.number.int({min: undefined, max: undefined}), needs_attention_count: faker.number.int({min: undefined, max: undefined}), ...overrideResponse})

export const getConfirmMappingApiV1IngestionConfirmMappingPostResponseMock = (overrideResponse: Partial< ConfirmMappingResponse > = {}): ConfirmMappingResponse => ({schema_mapping_id: faker.string.alpha({length: {min: 10, max: 20}}), data_source_id: faker.string.alpha({length: {min: 10, max: 20}}), learned_aliases: faker.number.int({min: undefined, max: undefined}), message: faker.string.alpha({length: {min: 10, max: 20}}), ...overrideResponse})

export const getGetAvailableFieldsApiV1IngestionFieldsGetResponseMock = (): AvailableField[] => (Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({field: faker.string.alpha({length: {min: 10, max: 20}}), description: faker.string.alpha({length: {min: 10, max: 20}})})))

export const getPromoteToProductionApiV1IngestionPromoteRawImportIdPostResponseMock = (): PromoteToProductionApiV1IngestionPromoteRawImportIdPost200 => ({})

export const getGetMappingStateApiV1IngestionMappingStateRawImportIdGetResponseMock = (overrideResponse: Partial< ProcessingResponse > = {}): ProcessingResponse => ({raw_import_id: faker.string.alpha({length: {min: 10, max: 20}}), filename: faker.string.alpha({length: {min: 10, max: 20}}), columns: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({source_column: faker.string.alpha({length: {min: 10, max: 20}}), target_field: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}),null,]), undefined]), confidence: faker.number.float({min: 0, max: 1, fractionDigits: 2}), tier: faker.helpers.arrayElement(Object.values(MatchTier)), fuzzy_score: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.number.float({min: undefined, max: undefined, fractionDigits: 2}),null,]), undefined]), reasoning: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}),null,]), undefined]), sample_data: faker.helpers.arrayElement([Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({})), undefined]), needs_review: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), ignored: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), status: faker.string.alpha({length: {min: 10, max: 20}})})), stats: faker.helpers.arrayElement([{}, undefined]), auto_mapped_count: faker.number.int({min: undefined, max: undefined}), needs_review_count: faker.number.int({min: undefined, max: undefined}), needs_attention_count: faker.number.int({min: undefined, max: undefined}), ...overrideResponse})


export const getGetUploadHistoryApiV1IngestionHistoryGetMockHandler = (overrideResponse?: unknown | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<unknown> | unknown), options?: RequestHandlerOptions) => {
  return http.get('*/api/v1/ingestion/history', async (info) => {await delay(1000);
  if (typeof overrideResponse === 'function') {await overrideResponse(info); }
    return new HttpResponse(null,
      { status: 200,
        
      })
  }, options)
}

export const getUploadFileForIngestionApiV1IngestionUploadPostMockHandler = (overrideResponse?: UploadFileForIngestionApiV1IngestionUploadPost200 | ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<UploadFileForIngestionApiV1IngestionUploadPost200> | UploadFileForIngestionApiV1IngestionUploadPost200), options?: RequestHandlerOptions) => {
  return http.post('*/api/v1/ingestion/upload', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getUploadFileForIngestionApiV1IngestionUploadPostResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getProcessFileApiV1IngestionProcessRawImportIdPostMockHandler = (overrideResponse?: ProcessingResponse | ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<ProcessingResponse> | ProcessingResponse), options?: RequestHandlerOptions) => {
  return http.post('*/api/v1/ingestion/process/:rawImportId', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getProcessFileApiV1IngestionProcessRawImportIdPostResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getConfirmMappingApiV1IngestionConfirmMappingPostMockHandler = (overrideResponse?: ConfirmMappingResponse | ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<ConfirmMappingResponse> | ConfirmMappingResponse), options?: RequestHandlerOptions) => {
  return http.post('*/api/v1/ingestion/confirm-mapping', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getConfirmMappingApiV1IngestionConfirmMappingPostResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getGetAvailableFieldsApiV1IngestionFieldsGetMockHandler = (overrideResponse?: AvailableField[] | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<AvailableField[]> | AvailableField[]), options?: RequestHandlerOptions) => {
  return http.get('*/api/v1/ingestion/fields', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getGetAvailableFieldsApiV1IngestionFieldsGetResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getGetDateFormatsApiV1IngestionDateFormatsGetMockHandler = (overrideResponse?: unknown | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<unknown> | unknown), options?: RequestHandlerOptions) => {
  return http.get('*/api/v1/ingestion/date-formats', async (info) => {await delay(1000);
  if (typeof overrideResponse === 'function') {await overrideResponse(info); }
    return new HttpResponse(null,
      { status: 200,
        
      })
  }, options)
}

export const getListUploadsApiV1IngestionUploadsGetMockHandler = (overrideResponse?: unknown | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<unknown> | unknown), options?: RequestHandlerOptions) => {
  return http.get('*/api/v1/ingestion/uploads', async (info) => {await delay(1000);
  if (typeof overrideResponse === 'function') {await overrideResponse(info); }
    return new HttpResponse(null,
      { status: 200,
        
      })
  }, options)
}

export const getDeleteUploadsApiV1IngestionUploadsDeleteMockHandler = (overrideResponse?: void | ((info: Parameters<Parameters<typeof http.delete>[1]>[0]) => Promise<void> | void), options?: RequestHandlerOptions) => {
  return http.delete('*/api/v1/ingestion/uploads', async (info) => {await delay(1000);
  if (typeof overrideResponse === 'function') {await overrideResponse(info); }
    return new HttpResponse(null,
      { status: 204,
        
      })
  }, options)
}

export const getDownloadFileApiV1IngestionFilesRawImportIdDownloadGetMockHandler = (overrideResponse?: unknown | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<unknown> | unknown), options?: RequestHandlerOptions) => {
  return http.get('*/api/v1/ingestion/files/:rawImportId/download', async (info) => {await delay(1000);
  if (typeof overrideResponse === 'function') {await overrideResponse(info); }
    return new HttpResponse(null,
      { status: 200,
        
      })
  }, options)
}

export const getGetImportPreviewApiV1IngestionPreviewRawImportIdGetMockHandler = (overrideResponse?: unknown | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<unknown> | unknown), options?: RequestHandlerOptions) => {
  return http.get('*/api/v1/ingestion/preview/:rawImportId', async (info) => {await delay(1000);
  if (typeof overrideResponse === 'function') {await overrideResponse(info); }
    return new HttpResponse(null,
      { status: 200,
        
      })
  }, options)
}

export const getGetDryRunPreviewApiV1IngestionPreviewDryRunRawImportIdGetMockHandler = (overrideResponse?: unknown | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<unknown> | unknown), options?: RequestHandlerOptions) => {
  return http.get('*/api/v1/ingestion/preview-dry-run/:rawImportId', async (info) => {await delay(1000);
  if (typeof overrideResponse === 'function') {await overrideResponse(info); }
    return new HttpResponse(null,
      { status: 200,
        
      })
  }, options)
}

export const getPromoteToProductionApiV1IngestionPromoteRawImportIdPostMockHandler = (overrideResponse?: PromoteToProductionApiV1IngestionPromoteRawImportIdPost200 | ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<PromoteToProductionApiV1IngestionPromoteRawImportIdPost200> | PromoteToProductionApiV1IngestionPromoteRawImportIdPost200), options?: RequestHandlerOptions) => {
  return http.post('*/api/v1/ingestion/promote/:rawImportId', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getPromoteToProductionApiV1IngestionPromoteRawImportIdPostResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getGetMappingStateApiV1IngestionMappingStateRawImportIdGetMockHandler = (overrideResponse?: ProcessingResponse | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<ProcessingResponse> | ProcessingResponse), options?: RequestHandlerOptions) => {
  return http.get('*/api/v1/ingestion/mapping-state/:rawImportId', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getGetMappingStateApiV1IngestionMappingStateRawImportIdGetResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}
export const getDataIngestionMock = () => [
  getGetUploadHistoryApiV1IngestionHistoryGetMockHandler(),
  getUploadFileForIngestionApiV1IngestionUploadPostMockHandler(),
  getProcessFileApiV1IngestionProcessRawImportIdPostMockHandler(),
  getConfirmMappingApiV1IngestionConfirmMappingPostMockHandler(),
  getGetAvailableFieldsApiV1IngestionFieldsGetMockHandler(),
  getGetDateFormatsApiV1IngestionDateFormatsGetMockHandler(),
  getListUploadsApiV1IngestionUploadsGetMockHandler(),
  getDeleteUploadsApiV1IngestionUploadsDeleteMockHandler(),
  getDownloadFileApiV1IngestionFilesRawImportIdDownloadGetMockHandler(),
  getGetImportPreviewApiV1IngestionPreviewRawImportIdGetMockHandler(),
  getGetDryRunPreviewApiV1IngestionPreviewDryRunRawImportIdGetMockHandler(),
  getPromoteToProductionApiV1IngestionPromoteRawImportIdPostMockHandler(),
  getGetMappingStateApiV1IngestionMappingStateRawImportIdGetMockHandler()
]
