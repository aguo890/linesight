/**
 * Generated by orval v7.13.2 üç∫
 * Do not edit manually.
 * LineSight
 * LineSight: AI-driven Semantic ETL platform for SMB apparel manufacturing. Parse messy Excel files, track SAM/DHU metrics, and ensure UFLPA compliance.
 * OpenAPI spec version: 0.1.0
 */
import {
  useMutation,
  useQuery
} from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import type {
  AvailableField,
  BodyUploadFileForIngestionApiV1IngestionUploadPost,
  ConfirmMappingRequest,
  ConfirmMappingResponse,
  DeleteUploadsApiV1IngestionUploadsDeleteParams,
  GetUploadHistoryApiV1IngestionHistoryGetParams,
  HTTPValidationError,
  ListUploadsApiV1IngestionUploadsGetParams,
  ProcessFileApiV1IngestionProcessRawImportIdPostParams,
  ProcessingResponse,
  PromoteToProductionApiV1IngestionPromoteRawImportIdPost200,
  UploadFileForIngestionApiV1IngestionUploadPost200,
  UploadFileForIngestionApiV1IngestionUploadPostParams
} from '../../model';

import { customInstance } from '../../axios-client';


type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];



/**
 * Fetch recent file uploads, optionally filtered by data source.
 * @summary Get Upload History
 */
export const getUploadHistoryApiV1IngestionHistoryGet = (
    params?: GetUploadHistoryApiV1IngestionHistoryGetParams,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<unknown>(
      {url: `/api/v1/ingestion/history`, method: 'GET',
        params, signal
    },
      options);
    }
  



export const getGetUploadHistoryApiV1IngestionHistoryGetQueryKey = (params?: GetUploadHistoryApiV1IngestionHistoryGetParams,) => {
    return [
    `/api/v1/ingestion/history`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getGetUploadHistoryApiV1IngestionHistoryGetQueryOptions = <TData = Awaited<ReturnType<typeof getUploadHistoryApiV1IngestionHistoryGet>>, TError = HTTPValidationError>(params?: GetUploadHistoryApiV1IngestionHistoryGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUploadHistoryApiV1IngestionHistoryGet>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetUploadHistoryApiV1IngestionHistoryGetQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getUploadHistoryApiV1IngestionHistoryGet>>> = ({ signal }) => getUploadHistoryApiV1IngestionHistoryGet(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getUploadHistoryApiV1IngestionHistoryGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetUploadHistoryApiV1IngestionHistoryGetQueryResult = NonNullable<Awaited<ReturnType<typeof getUploadHistoryApiV1IngestionHistoryGet>>>
export type GetUploadHistoryApiV1IngestionHistoryGetQueryError = HTTPValidationError


export function useGetUploadHistoryApiV1IngestionHistoryGet<TData = Awaited<ReturnType<typeof getUploadHistoryApiV1IngestionHistoryGet>>, TError = HTTPValidationError>(
 params: undefined |  GetUploadHistoryApiV1IngestionHistoryGetParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUploadHistoryApiV1IngestionHistoryGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getUploadHistoryApiV1IngestionHistoryGet>>,
          TError,
          Awaited<ReturnType<typeof getUploadHistoryApiV1IngestionHistoryGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetUploadHistoryApiV1IngestionHistoryGet<TData = Awaited<ReturnType<typeof getUploadHistoryApiV1IngestionHistoryGet>>, TError = HTTPValidationError>(
 params?: GetUploadHistoryApiV1IngestionHistoryGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUploadHistoryApiV1IngestionHistoryGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getUploadHistoryApiV1IngestionHistoryGet>>,
          TError,
          Awaited<ReturnType<typeof getUploadHistoryApiV1IngestionHistoryGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetUploadHistoryApiV1IngestionHistoryGet<TData = Awaited<ReturnType<typeof getUploadHistoryApiV1IngestionHistoryGet>>, TError = HTTPValidationError>(
 params?: GetUploadHistoryApiV1IngestionHistoryGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUploadHistoryApiV1IngestionHistoryGet>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Upload History
 */

export function useGetUploadHistoryApiV1IngestionHistoryGet<TData = Awaited<ReturnType<typeof getUploadHistoryApiV1IngestionHistoryGet>>, TError = HTTPValidationError>(
 params?: GetUploadHistoryApiV1IngestionHistoryGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUploadHistoryApiV1IngestionHistoryGet>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetUploadHistoryApiV1IngestionHistoryGetQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * Upload a file and create a RawImport record.

This is step 1 of the HITL flow. The file is saved and parsed.
Storage structure: uploads/{factory_id}/{data_source_id}/{year}/{month}/{filename}

REQUIRES: factory_id - Data must be uploaded to a specific factory.
OPTIONAL: data_source_id - If provided, upload is associated with a specific data source.
 * @summary Upload File For Ingestion
 */
export const uploadFileForIngestionApiV1IngestionUploadPost = (
    bodyUploadFileForIngestionApiV1IngestionUploadPost: BodyUploadFileForIngestionApiV1IngestionUploadPost,
    params: UploadFileForIngestionApiV1IngestionUploadPostParams,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      const formData = new FormData();
formData.append(`file`, bodyUploadFileForIngestionApiV1IngestionUploadPost.file)

      return customInstance<UploadFileForIngestionApiV1IngestionUploadPost200>(
      {url: `/api/v1/ingestion/upload`, method: 'POST',
      headers: {'Content-Type': 'multipart/form-data', },
       data: formData,
        params, signal
    },
      options);
    }
  


export const getUploadFileForIngestionApiV1IngestionUploadPostMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof uploadFileForIngestionApiV1IngestionUploadPost>>, TError,{data: BodyUploadFileForIngestionApiV1IngestionUploadPost;params: UploadFileForIngestionApiV1IngestionUploadPostParams}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof uploadFileForIngestionApiV1IngestionUploadPost>>, TError,{data: BodyUploadFileForIngestionApiV1IngestionUploadPost;params: UploadFileForIngestionApiV1IngestionUploadPostParams}, TContext> => {

const mutationKey = ['uploadFileForIngestionApiV1IngestionUploadPost'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof uploadFileForIngestionApiV1IngestionUploadPost>>, {data: BodyUploadFileForIngestionApiV1IngestionUploadPost;params: UploadFileForIngestionApiV1IngestionUploadPostParams}> = (props) => {
          const {data,params} = props ?? {};

          return  uploadFileForIngestionApiV1IngestionUploadPost(data,params,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UploadFileForIngestionApiV1IngestionUploadPostMutationResult = NonNullable<Awaited<ReturnType<typeof uploadFileForIngestionApiV1IngestionUploadPost>>>
    export type UploadFileForIngestionApiV1IngestionUploadPostMutationBody = BodyUploadFileForIngestionApiV1IngestionUploadPost
    export type UploadFileForIngestionApiV1IngestionUploadPostMutationError = HTTPValidationError

    /**
 * @summary Upload File For Ingestion
 */
export const useUploadFileForIngestionApiV1IngestionUploadPost = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof uploadFileForIngestionApiV1IngestionUploadPost>>, TError,{data: BodyUploadFileForIngestionApiV1IngestionUploadPost;params: UploadFileForIngestionApiV1IngestionUploadPostParams}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof uploadFileForIngestionApiV1IngestionUploadPost>>,
        TError,
        {data: BodyUploadFileForIngestionApiV1IngestionUploadPost;params: UploadFileForIngestionApiV1IngestionUploadPostParams},
        TContext
      > => {

      const mutationOptions = getUploadFileForIngestionApiV1IngestionUploadPostMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Process an uploaded file through the Hybrid Waterfall Matching Engine.

This is step 2 of the HITL flow. Returns column mappings with confidence scores.
 * @summary Process File
 */
export const processFileApiV1IngestionProcessRawImportIdPost = (
    rawImportId: string,
    params?: ProcessFileApiV1IngestionProcessRawImportIdPostParams,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<ProcessingResponse>(
      {url: `/api/v1/ingestion/process/${rawImportId}`, method: 'POST',
        params, signal
    },
      options);
    }
  


export const getProcessFileApiV1IngestionProcessRawImportIdPostMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof processFileApiV1IngestionProcessRawImportIdPost>>, TError,{rawImportId: string;params?: ProcessFileApiV1IngestionProcessRawImportIdPostParams}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof processFileApiV1IngestionProcessRawImportIdPost>>, TError,{rawImportId: string;params?: ProcessFileApiV1IngestionProcessRawImportIdPostParams}, TContext> => {

const mutationKey = ['processFileApiV1IngestionProcessRawImportIdPost'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof processFileApiV1IngestionProcessRawImportIdPost>>, {rawImportId: string;params?: ProcessFileApiV1IngestionProcessRawImportIdPostParams}> = (props) => {
          const {rawImportId,params} = props ?? {};

          return  processFileApiV1IngestionProcessRawImportIdPost(rawImportId,params,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ProcessFileApiV1IngestionProcessRawImportIdPostMutationResult = NonNullable<Awaited<ReturnType<typeof processFileApiV1IngestionProcessRawImportIdPost>>>
    
    export type ProcessFileApiV1IngestionProcessRawImportIdPostMutationError = HTTPValidationError

    /**
 * @summary Process File
 */
export const useProcessFileApiV1IngestionProcessRawImportIdPost = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof processFileApiV1IngestionProcessRawImportIdPost>>, TError,{rawImportId: string;params?: ProcessFileApiV1IngestionProcessRawImportIdPostParams}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof processFileApiV1IngestionProcessRawImportIdPost>>,
        TError,
        {rawImportId: string;params?: ProcessFileApiV1IngestionProcessRawImportIdPostParams},
        TContext
      > => {

      const mutationOptions = getProcessFileApiV1IngestionProcessRawImportIdPostMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Confirm column mappings after user review.

This is step 3 of the HITL flow. Saves the mapping and optionally
learns from user corrections for future matching.
 * @summary Confirm Mapping
 */
export const confirmMappingApiV1IngestionConfirmMappingPost = (
    confirmMappingRequest: ConfirmMappingRequest,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<ConfirmMappingResponse>(
      {url: `/api/v1/ingestion/confirm-mapping`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: confirmMappingRequest, signal
    },
      options);
    }
  


export const getConfirmMappingApiV1IngestionConfirmMappingPostMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof confirmMappingApiV1IngestionConfirmMappingPost>>, TError,{data: ConfirmMappingRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof confirmMappingApiV1IngestionConfirmMappingPost>>, TError,{data: ConfirmMappingRequest}, TContext> => {

const mutationKey = ['confirmMappingApiV1IngestionConfirmMappingPost'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof confirmMappingApiV1IngestionConfirmMappingPost>>, {data: ConfirmMappingRequest}> = (props) => {
          const {data} = props ?? {};

          return  confirmMappingApiV1IngestionConfirmMappingPost(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ConfirmMappingApiV1IngestionConfirmMappingPostMutationResult = NonNullable<Awaited<ReturnType<typeof confirmMappingApiV1IngestionConfirmMappingPost>>>
    export type ConfirmMappingApiV1IngestionConfirmMappingPostMutationBody = ConfirmMappingRequest
    export type ConfirmMappingApiV1IngestionConfirmMappingPostMutationError = HTTPValidationError

    /**
 * @summary Confirm Mapping
 */
export const useConfirmMappingApiV1IngestionConfirmMappingPost = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof confirmMappingApiV1IngestionConfirmMappingPost>>, TError,{data: ConfirmMappingRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof confirmMappingApiV1IngestionConfirmMappingPost>>,
        TError,
        {data: ConfirmMappingRequest},
        TContext
      > => {

      const mutationOptions = getConfirmMappingApiV1IngestionConfirmMappingPostMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Get list of available canonical fields for UI dropdown.
 * @summary Get Available Fields
 */
export const getAvailableFieldsApiV1IngestionFieldsGet = (
    
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<AvailableField[]>(
      {url: `/api/v1/ingestion/fields`, method: 'GET', signal
    },
      options);
    }
  



export const getGetAvailableFieldsApiV1IngestionFieldsGetQueryKey = () => {
    return [
    `/api/v1/ingestion/fields`
    ] as const;
    }

    
export const getGetAvailableFieldsApiV1IngestionFieldsGetQueryOptions = <TData = Awaited<ReturnType<typeof getAvailableFieldsApiV1IngestionFieldsGet>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAvailableFieldsApiV1IngestionFieldsGet>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAvailableFieldsApiV1IngestionFieldsGetQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAvailableFieldsApiV1IngestionFieldsGet>>> = ({ signal }) => getAvailableFieldsApiV1IngestionFieldsGet(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAvailableFieldsApiV1IngestionFieldsGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetAvailableFieldsApiV1IngestionFieldsGetQueryResult = NonNullable<Awaited<ReturnType<typeof getAvailableFieldsApiV1IngestionFieldsGet>>>
export type GetAvailableFieldsApiV1IngestionFieldsGetQueryError = unknown


export function useGetAvailableFieldsApiV1IngestionFieldsGet<TData = Awaited<ReturnType<typeof getAvailableFieldsApiV1IngestionFieldsGet>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAvailableFieldsApiV1IngestionFieldsGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAvailableFieldsApiV1IngestionFieldsGet>>,
          TError,
          Awaited<ReturnType<typeof getAvailableFieldsApiV1IngestionFieldsGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAvailableFieldsApiV1IngestionFieldsGet<TData = Awaited<ReturnType<typeof getAvailableFieldsApiV1IngestionFieldsGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAvailableFieldsApiV1IngestionFieldsGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAvailableFieldsApiV1IngestionFieldsGet>>,
          TError,
          Awaited<ReturnType<typeof getAvailableFieldsApiV1IngestionFieldsGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAvailableFieldsApiV1IngestionFieldsGet<TData = Awaited<ReturnType<typeof getAvailableFieldsApiV1IngestionFieldsGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAvailableFieldsApiV1IngestionFieldsGet>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Available Fields
 */

export function useGetAvailableFieldsApiV1IngestionFieldsGet<TData = Awaited<ReturnType<typeof getAvailableFieldsApiV1IngestionFieldsGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAvailableFieldsApiV1IngestionFieldsGet>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetAvailableFieldsApiV1IngestionFieldsGetQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * Get list of available date format options for UI dropdown.

Returns list of {value, label} objects for select component.
The 'value' should be stored in DataSource.time_format.
 * @summary Get Date Formats
 */
export const getDateFormatsApiV1IngestionDateFormatsGet = (
    
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<unknown>(
      {url: `/api/v1/ingestion/date-formats`, method: 'GET', signal
    },
      options);
    }
  



export const getGetDateFormatsApiV1IngestionDateFormatsGetQueryKey = () => {
    return [
    `/api/v1/ingestion/date-formats`
    ] as const;
    }

    
export const getGetDateFormatsApiV1IngestionDateFormatsGetQueryOptions = <TData = Awaited<ReturnType<typeof getDateFormatsApiV1IngestionDateFormatsGet>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDateFormatsApiV1IngestionDateFormatsGet>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetDateFormatsApiV1IngestionDateFormatsGetQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getDateFormatsApiV1IngestionDateFormatsGet>>> = ({ signal }) => getDateFormatsApiV1IngestionDateFormatsGet(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getDateFormatsApiV1IngestionDateFormatsGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetDateFormatsApiV1IngestionDateFormatsGetQueryResult = NonNullable<Awaited<ReturnType<typeof getDateFormatsApiV1IngestionDateFormatsGet>>>
export type GetDateFormatsApiV1IngestionDateFormatsGetQueryError = unknown


export function useGetDateFormatsApiV1IngestionDateFormatsGet<TData = Awaited<ReturnType<typeof getDateFormatsApiV1IngestionDateFormatsGet>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDateFormatsApiV1IngestionDateFormatsGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDateFormatsApiV1IngestionDateFormatsGet>>,
          TError,
          Awaited<ReturnType<typeof getDateFormatsApiV1IngestionDateFormatsGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetDateFormatsApiV1IngestionDateFormatsGet<TData = Awaited<ReturnType<typeof getDateFormatsApiV1IngestionDateFormatsGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDateFormatsApiV1IngestionDateFormatsGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDateFormatsApiV1IngestionDateFormatsGet>>,
          TError,
          Awaited<ReturnType<typeof getDateFormatsApiV1IngestionDateFormatsGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetDateFormatsApiV1IngestionDateFormatsGet<TData = Awaited<ReturnType<typeof getDateFormatsApiV1IngestionDateFormatsGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDateFormatsApiV1IngestionDateFormatsGet>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Date Formats
 */

export function useGetDateFormatsApiV1IngestionDateFormatsGet<TData = Awaited<ReturnType<typeof getDateFormatsApiV1IngestionDateFormatsGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDateFormatsApiV1IngestionDateFormatsGet>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetDateFormatsApiV1IngestionDateFormatsGetQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * List uploaded files with optional filtering by production line or factory.

Returns paginated list of uploads for display in UI.
 * @summary List Uploads
 */
export const listUploadsApiV1IngestionUploadsGet = (
    params?: ListUploadsApiV1IngestionUploadsGetParams,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<unknown>(
      {url: `/api/v1/ingestion/uploads`, method: 'GET',
        params, signal
    },
      options);
    }
  



export const getListUploadsApiV1IngestionUploadsGetQueryKey = (params?: ListUploadsApiV1IngestionUploadsGetParams,) => {
    return [
    `/api/v1/ingestion/uploads`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getListUploadsApiV1IngestionUploadsGetQueryOptions = <TData = Awaited<ReturnType<typeof listUploadsApiV1IngestionUploadsGet>>, TError = HTTPValidationError>(params?: ListUploadsApiV1IngestionUploadsGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listUploadsApiV1IngestionUploadsGet>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getListUploadsApiV1IngestionUploadsGetQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof listUploadsApiV1IngestionUploadsGet>>> = ({ signal }) => listUploadsApiV1IngestionUploadsGet(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof listUploadsApiV1IngestionUploadsGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ListUploadsApiV1IngestionUploadsGetQueryResult = NonNullable<Awaited<ReturnType<typeof listUploadsApiV1IngestionUploadsGet>>>
export type ListUploadsApiV1IngestionUploadsGetQueryError = HTTPValidationError


export function useListUploadsApiV1IngestionUploadsGet<TData = Awaited<ReturnType<typeof listUploadsApiV1IngestionUploadsGet>>, TError = HTTPValidationError>(
 params: undefined |  ListUploadsApiV1IngestionUploadsGetParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof listUploadsApiV1IngestionUploadsGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof listUploadsApiV1IngestionUploadsGet>>,
          TError,
          Awaited<ReturnType<typeof listUploadsApiV1IngestionUploadsGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useListUploadsApiV1IngestionUploadsGet<TData = Awaited<ReturnType<typeof listUploadsApiV1IngestionUploadsGet>>, TError = HTTPValidationError>(
 params?: ListUploadsApiV1IngestionUploadsGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listUploadsApiV1IngestionUploadsGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof listUploadsApiV1IngestionUploadsGet>>,
          TError,
          Awaited<ReturnType<typeof listUploadsApiV1IngestionUploadsGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useListUploadsApiV1IngestionUploadsGet<TData = Awaited<ReturnType<typeof listUploadsApiV1IngestionUploadsGet>>, TError = HTTPValidationError>(
 params?: ListUploadsApiV1IngestionUploadsGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listUploadsApiV1IngestionUploadsGet>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary List Uploads
 */

export function useListUploadsApiV1IngestionUploadsGet<TData = Awaited<ReturnType<typeof listUploadsApiV1IngestionUploadsGet>>, TError = HTTPValidationError>(
 params?: ListUploadsApiV1IngestionUploadsGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listUploadsApiV1IngestionUploadsGet>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getListUploadsApiV1IngestionUploadsGetQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * Delete upload history for a production line.

This is a destructive action that:
1. Deletes RawImport records from the database
2. Deletes physical files from disk
 * @summary Delete Uploads
 */
export const deleteUploadsApiV1IngestionUploadsDelete = (
    params: DeleteUploadsApiV1IngestionUploadsDeleteParams,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<void>(
      {url: `/api/v1/ingestion/uploads`, method: 'DELETE',
        params
    },
      options);
    }
  


export const getDeleteUploadsApiV1IngestionUploadsDeleteMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteUploadsApiV1IngestionUploadsDelete>>, TError,{params: DeleteUploadsApiV1IngestionUploadsDeleteParams}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof deleteUploadsApiV1IngestionUploadsDelete>>, TError,{params: DeleteUploadsApiV1IngestionUploadsDeleteParams}, TContext> => {

const mutationKey = ['deleteUploadsApiV1IngestionUploadsDelete'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteUploadsApiV1IngestionUploadsDelete>>, {params: DeleteUploadsApiV1IngestionUploadsDeleteParams}> = (props) => {
          const {params} = props ?? {};

          return  deleteUploadsApiV1IngestionUploadsDelete(params,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteUploadsApiV1IngestionUploadsDeleteMutationResult = NonNullable<Awaited<ReturnType<typeof deleteUploadsApiV1IngestionUploadsDelete>>>
    
    export type DeleteUploadsApiV1IngestionUploadsDeleteMutationError = HTTPValidationError

    /**
 * @summary Delete Uploads
 */
export const useDeleteUploadsApiV1IngestionUploadsDelete = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteUploadsApiV1IngestionUploadsDelete>>, TError,{params: DeleteUploadsApiV1IngestionUploadsDeleteParams}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteUploadsApiV1IngestionUploadsDelete>>,
        TError,
        {params: DeleteUploadsApiV1IngestionUploadsDeleteParams},
        TContext
      > => {

      const mutationOptions = getDeleteUploadsApiV1IngestionUploadsDeleteMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Download the original uploaded file.

Returns file for download or viewing.
 * @summary Download File
 */
export const downloadFileApiV1IngestionFilesRawImportIdDownloadGet = (
    rawImportId: string,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<unknown>(
      {url: `/api/v1/ingestion/files/${rawImportId}/download`, method: 'GET', signal
    },
      options);
    }
  



export const getDownloadFileApiV1IngestionFilesRawImportIdDownloadGetQueryKey = (rawImportId?: string,) => {
    return [
    `/api/v1/ingestion/files/${rawImportId}/download`
    ] as const;
    }

    
export const getDownloadFileApiV1IngestionFilesRawImportIdDownloadGetQueryOptions = <TData = Awaited<ReturnType<typeof downloadFileApiV1IngestionFilesRawImportIdDownloadGet>>, TError = HTTPValidationError>(rawImportId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof downloadFileApiV1IngestionFilesRawImportIdDownloadGet>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getDownloadFileApiV1IngestionFilesRawImportIdDownloadGetQueryKey(rawImportId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof downloadFileApiV1IngestionFilesRawImportIdDownloadGet>>> = ({ signal }) => downloadFileApiV1IngestionFilesRawImportIdDownloadGet(rawImportId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(rawImportId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof downloadFileApiV1IngestionFilesRawImportIdDownloadGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type DownloadFileApiV1IngestionFilesRawImportIdDownloadGetQueryResult = NonNullable<Awaited<ReturnType<typeof downloadFileApiV1IngestionFilesRawImportIdDownloadGet>>>
export type DownloadFileApiV1IngestionFilesRawImportIdDownloadGetQueryError = HTTPValidationError


export function useDownloadFileApiV1IngestionFilesRawImportIdDownloadGet<TData = Awaited<ReturnType<typeof downloadFileApiV1IngestionFilesRawImportIdDownloadGet>>, TError = HTTPValidationError>(
 rawImportId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof downloadFileApiV1IngestionFilesRawImportIdDownloadGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof downloadFileApiV1IngestionFilesRawImportIdDownloadGet>>,
          TError,
          Awaited<ReturnType<typeof downloadFileApiV1IngestionFilesRawImportIdDownloadGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useDownloadFileApiV1IngestionFilesRawImportIdDownloadGet<TData = Awaited<ReturnType<typeof downloadFileApiV1IngestionFilesRawImportIdDownloadGet>>, TError = HTTPValidationError>(
 rawImportId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof downloadFileApiV1IngestionFilesRawImportIdDownloadGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof downloadFileApiV1IngestionFilesRawImportIdDownloadGet>>,
          TError,
          Awaited<ReturnType<typeof downloadFileApiV1IngestionFilesRawImportIdDownloadGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useDownloadFileApiV1IngestionFilesRawImportIdDownloadGet<TData = Awaited<ReturnType<typeof downloadFileApiV1IngestionFilesRawImportIdDownloadGet>>, TError = HTTPValidationError>(
 rawImportId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof downloadFileApiV1IngestionFilesRawImportIdDownloadGet>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Download File
 */

export function useDownloadFileApiV1IngestionFilesRawImportIdDownloadGet<TData = Awaited<ReturnType<typeof downloadFileApiV1IngestionFilesRawImportIdDownloadGet>>, TError = HTTPValidationError>(
 rawImportId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof downloadFileApiV1IngestionFilesRawImportIdDownloadGet>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getDownloadFileApiV1IngestionFilesRawImportIdDownloadGetQueryOptions(rawImportId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * Fetches formatted preview data for the frontend TablePreview interface.
 * @summary Get Import Preview
 */
export const getImportPreviewApiV1IngestionPreviewRawImportIdGet = (
    rawImportId: string,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<unknown>(
      {url: `/api/v1/ingestion/preview/${rawImportId}`, method: 'GET', signal
    },
      options);
    }
  



export const getGetImportPreviewApiV1IngestionPreviewRawImportIdGetQueryKey = (rawImportId?: string,) => {
    return [
    `/api/v1/ingestion/preview/${rawImportId}`
    ] as const;
    }

    
export const getGetImportPreviewApiV1IngestionPreviewRawImportIdGetQueryOptions = <TData = Awaited<ReturnType<typeof getImportPreviewApiV1IngestionPreviewRawImportIdGet>>, TError = HTTPValidationError>(rawImportId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getImportPreviewApiV1IngestionPreviewRawImportIdGet>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetImportPreviewApiV1IngestionPreviewRawImportIdGetQueryKey(rawImportId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getImportPreviewApiV1IngestionPreviewRawImportIdGet>>> = ({ signal }) => getImportPreviewApiV1IngestionPreviewRawImportIdGet(rawImportId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(rawImportId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getImportPreviewApiV1IngestionPreviewRawImportIdGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetImportPreviewApiV1IngestionPreviewRawImportIdGetQueryResult = NonNullable<Awaited<ReturnType<typeof getImportPreviewApiV1IngestionPreviewRawImportIdGet>>>
export type GetImportPreviewApiV1IngestionPreviewRawImportIdGetQueryError = HTTPValidationError


export function useGetImportPreviewApiV1IngestionPreviewRawImportIdGet<TData = Awaited<ReturnType<typeof getImportPreviewApiV1IngestionPreviewRawImportIdGet>>, TError = HTTPValidationError>(
 rawImportId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getImportPreviewApiV1IngestionPreviewRawImportIdGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getImportPreviewApiV1IngestionPreviewRawImportIdGet>>,
          TError,
          Awaited<ReturnType<typeof getImportPreviewApiV1IngestionPreviewRawImportIdGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetImportPreviewApiV1IngestionPreviewRawImportIdGet<TData = Awaited<ReturnType<typeof getImportPreviewApiV1IngestionPreviewRawImportIdGet>>, TError = HTTPValidationError>(
 rawImportId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getImportPreviewApiV1IngestionPreviewRawImportIdGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getImportPreviewApiV1IngestionPreviewRawImportIdGet>>,
          TError,
          Awaited<ReturnType<typeof getImportPreviewApiV1IngestionPreviewRawImportIdGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetImportPreviewApiV1IngestionPreviewRawImportIdGet<TData = Awaited<ReturnType<typeof getImportPreviewApiV1IngestionPreviewRawImportIdGet>>, TError = HTTPValidationError>(
 rawImportId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getImportPreviewApiV1IngestionPreviewRawImportIdGet>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Import Preview
 */

export function useGetImportPreviewApiV1IngestionPreviewRawImportIdGet<TData = Awaited<ReturnType<typeof getImportPreviewApiV1IngestionPreviewRawImportIdGet>>, TError = HTTPValidationError>(
 rawImportId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getImportPreviewApiV1IngestionPreviewRawImportIdGet>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetImportPreviewApiV1IngestionPreviewRawImportIdGetQueryOptions(rawImportId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * HITL Preview: Show how data will look after import.
Returns first 20 rows with before/after comparison.
 * @summary Get Dry Run Preview
 */
export const getDryRunPreviewApiV1IngestionPreviewDryRunRawImportIdGet = (
    rawImportId: string,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<unknown>(
      {url: `/api/v1/ingestion/preview-dry-run/${rawImportId}`, method: 'GET', signal
    },
      options);
    }
  



export const getGetDryRunPreviewApiV1IngestionPreviewDryRunRawImportIdGetQueryKey = (rawImportId?: string,) => {
    return [
    `/api/v1/ingestion/preview-dry-run/${rawImportId}`
    ] as const;
    }

    
export const getGetDryRunPreviewApiV1IngestionPreviewDryRunRawImportIdGetQueryOptions = <TData = Awaited<ReturnType<typeof getDryRunPreviewApiV1IngestionPreviewDryRunRawImportIdGet>>, TError = HTTPValidationError>(rawImportId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDryRunPreviewApiV1IngestionPreviewDryRunRawImportIdGet>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetDryRunPreviewApiV1IngestionPreviewDryRunRawImportIdGetQueryKey(rawImportId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getDryRunPreviewApiV1IngestionPreviewDryRunRawImportIdGet>>> = ({ signal }) => getDryRunPreviewApiV1IngestionPreviewDryRunRawImportIdGet(rawImportId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(rawImportId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getDryRunPreviewApiV1IngestionPreviewDryRunRawImportIdGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetDryRunPreviewApiV1IngestionPreviewDryRunRawImportIdGetQueryResult = NonNullable<Awaited<ReturnType<typeof getDryRunPreviewApiV1IngestionPreviewDryRunRawImportIdGet>>>
export type GetDryRunPreviewApiV1IngestionPreviewDryRunRawImportIdGetQueryError = HTTPValidationError


export function useGetDryRunPreviewApiV1IngestionPreviewDryRunRawImportIdGet<TData = Awaited<ReturnType<typeof getDryRunPreviewApiV1IngestionPreviewDryRunRawImportIdGet>>, TError = HTTPValidationError>(
 rawImportId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDryRunPreviewApiV1IngestionPreviewDryRunRawImportIdGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDryRunPreviewApiV1IngestionPreviewDryRunRawImportIdGet>>,
          TError,
          Awaited<ReturnType<typeof getDryRunPreviewApiV1IngestionPreviewDryRunRawImportIdGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetDryRunPreviewApiV1IngestionPreviewDryRunRawImportIdGet<TData = Awaited<ReturnType<typeof getDryRunPreviewApiV1IngestionPreviewDryRunRawImportIdGet>>, TError = HTTPValidationError>(
 rawImportId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDryRunPreviewApiV1IngestionPreviewDryRunRawImportIdGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDryRunPreviewApiV1IngestionPreviewDryRunRawImportIdGet>>,
          TError,
          Awaited<ReturnType<typeof getDryRunPreviewApiV1IngestionPreviewDryRunRawImportIdGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetDryRunPreviewApiV1IngestionPreviewDryRunRawImportIdGet<TData = Awaited<ReturnType<typeof getDryRunPreviewApiV1IngestionPreviewDryRunRawImportIdGet>>, TError = HTTPValidationError>(
 rawImportId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDryRunPreviewApiV1IngestionPreviewDryRunRawImportIdGet>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Dry Run Preview
 */

export function useGetDryRunPreviewApiV1IngestionPreviewDryRunRawImportIdGet<TData = Awaited<ReturnType<typeof getDryRunPreviewApiV1IngestionPreviewDryRunRawImportIdGet>>, TError = HTTPValidationError>(
 rawImportId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDryRunPreviewApiV1IngestionPreviewDryRunRawImportIdGet>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetDryRunPreviewApiV1IngestionPreviewDryRunRawImportIdGetQueryOptions(rawImportId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * Step 4: Promote data from a confirmed RawImport to production tables.
Matches records to Style/Order models and creates ProductionRuns.
 * @summary Promote To Production
 */
export const promoteToProductionApiV1IngestionPromoteRawImportIdPost = (
    rawImportId: string,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<PromoteToProductionApiV1IngestionPromoteRawImportIdPost200>(
      {url: `/api/v1/ingestion/promote/${rawImportId}`, method: 'POST', signal
    },
      options);
    }
  


export const getPromoteToProductionApiV1IngestionPromoteRawImportIdPostMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof promoteToProductionApiV1IngestionPromoteRawImportIdPost>>, TError,{rawImportId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof promoteToProductionApiV1IngestionPromoteRawImportIdPost>>, TError,{rawImportId: string}, TContext> => {

const mutationKey = ['promoteToProductionApiV1IngestionPromoteRawImportIdPost'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof promoteToProductionApiV1IngestionPromoteRawImportIdPost>>, {rawImportId: string}> = (props) => {
          const {rawImportId} = props ?? {};

          return  promoteToProductionApiV1IngestionPromoteRawImportIdPost(rawImportId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PromoteToProductionApiV1IngestionPromoteRawImportIdPostMutationResult = NonNullable<Awaited<ReturnType<typeof promoteToProductionApiV1IngestionPromoteRawImportIdPost>>>
    
    export type PromoteToProductionApiV1IngestionPromoteRawImportIdPostMutationError = HTTPValidationError

    /**
 * @summary Promote To Production
 */
export const usePromoteToProductionApiV1IngestionPromoteRawImportIdPost = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof promoteToProductionApiV1IngestionPromoteRawImportIdPost>>, TError,{rawImportId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof promoteToProductionApiV1IngestionPromoteRawImportIdPost>>,
        TError,
        {rawImportId: string},
        TContext
      > => {

      const mutationOptions = getPromoteToProductionApiV1IngestionPromoteRawImportIdPostMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Retrieves the current mapping state for a file without re-running the matching engine.
Used when a user returns to a partially configured or already processed upload.
 * @summary Get Mapping State
 */
export const getMappingStateApiV1IngestionMappingStateRawImportIdGet = (
    rawImportId: string,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<ProcessingResponse>(
      {url: `/api/v1/ingestion/mapping-state/${rawImportId}`, method: 'GET', signal
    },
      options);
    }
  



export const getGetMappingStateApiV1IngestionMappingStateRawImportIdGetQueryKey = (rawImportId?: string,) => {
    return [
    `/api/v1/ingestion/mapping-state/${rawImportId}`
    ] as const;
    }

    
export const getGetMappingStateApiV1IngestionMappingStateRawImportIdGetQueryOptions = <TData = Awaited<ReturnType<typeof getMappingStateApiV1IngestionMappingStateRawImportIdGet>>, TError = HTTPValidationError>(rawImportId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMappingStateApiV1IngestionMappingStateRawImportIdGet>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetMappingStateApiV1IngestionMappingStateRawImportIdGetQueryKey(rawImportId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getMappingStateApiV1IngestionMappingStateRawImportIdGet>>> = ({ signal }) => getMappingStateApiV1IngestionMappingStateRawImportIdGet(rawImportId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(rawImportId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getMappingStateApiV1IngestionMappingStateRawImportIdGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetMappingStateApiV1IngestionMappingStateRawImportIdGetQueryResult = NonNullable<Awaited<ReturnType<typeof getMappingStateApiV1IngestionMappingStateRawImportIdGet>>>
export type GetMappingStateApiV1IngestionMappingStateRawImportIdGetQueryError = HTTPValidationError


export function useGetMappingStateApiV1IngestionMappingStateRawImportIdGet<TData = Awaited<ReturnType<typeof getMappingStateApiV1IngestionMappingStateRawImportIdGet>>, TError = HTTPValidationError>(
 rawImportId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMappingStateApiV1IngestionMappingStateRawImportIdGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMappingStateApiV1IngestionMappingStateRawImportIdGet>>,
          TError,
          Awaited<ReturnType<typeof getMappingStateApiV1IngestionMappingStateRawImportIdGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetMappingStateApiV1IngestionMappingStateRawImportIdGet<TData = Awaited<ReturnType<typeof getMappingStateApiV1IngestionMappingStateRawImportIdGet>>, TError = HTTPValidationError>(
 rawImportId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMappingStateApiV1IngestionMappingStateRawImportIdGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMappingStateApiV1IngestionMappingStateRawImportIdGet>>,
          TError,
          Awaited<ReturnType<typeof getMappingStateApiV1IngestionMappingStateRawImportIdGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetMappingStateApiV1IngestionMappingStateRawImportIdGet<TData = Awaited<ReturnType<typeof getMappingStateApiV1IngestionMappingStateRawImportIdGet>>, TError = HTTPValidationError>(
 rawImportId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMappingStateApiV1IngestionMappingStateRawImportIdGet>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Mapping State
 */

export function useGetMappingStateApiV1IngestionMappingStateRawImportIdGet<TData = Awaited<ReturnType<typeof getMappingStateApiV1IngestionMappingStateRawImportIdGet>>, TError = HTTPValidationError>(
 rawImportId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMappingStateApiV1IngestionMappingStateRawImportIdGet>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetMappingStateApiV1IngestionMappingStateRawImportIdGetQueryOptions(rawImportId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



